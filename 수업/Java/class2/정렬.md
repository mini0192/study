# 선택 정렬

배열에서 최대값 혹은 최소값을 찾아 정렬되지 않은 부분의 첫번째 원소와 교환하는 방식으로 정렬을 한다.

| 최악 | 평균 | 최선 |
|-|-|-|
| $N^2$ | $N^2$ | $N^2$

![img](https://blog.kakaocdn.net/dn/blSBFD/btqPem0zr5m/hh4Q5i81KoUXHUwC8TyKik/img.gif)


# 삽입 정렬
배열에서 정렬된 부분과 정렬되지 않은 부분을 나누어 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입하는 방식의 알고리즘

| 최악 | 평균 | 최선 |
|-|-|-|
| $N^2$ | $N^2$ | $N$

![img](https://cdn-images-1.medium.com/max/1600/1*IK3Q4NBRLthllMINV3OxpQ.gif)


# 버블 정렬
서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘

| 최악 | 평균 | 최선 |
|-|-|-|
| $N^2$ | $N^2$ | $N$ |

![img](https://cdn-images-1.medium.com/max/1600/1*ZQmdM7My9QIhvxj98hrweg.gif)

# 병합 정렬
정렬할 리스트를 반으로 쪼개나가며 좌측과 우측 리스트를 계속하여 분할해 나간 후 각 리스트내에서 병합 정렬 후 병합하는 과정을 통해 정렬하는 알고리즘

| 최악 | 평균 | 최선 |
|-|-|-|
| $NlogN$ | $NlogN$ | $NlogN$ |

![img](https://cdn-images-1.medium.com/max/1600/1*Uvs7CK1oew0pVckcuxr_qA.gif)

# 퀵 정렬
피벗을 선택하고 피벗을 기준으로 배열을 두 부분으로 나눠 재귀적으로 두 부분을 정렬하는 방식

| 최악 | 평균 | 최선 |
|-|-|-|
| $N^2$ | $NlogN$ | $NlogN$ |

![img](https://cdn-images-1.medium.com/max/1600/1*wwCw5TzLd79k2WQ6YVsQVw.gif)

## 병합 정렬과 퀵 정렬의 비교
### 공간 복잡도

***병합 정렬***: 배열을 두 부분으로 나눈 후 병합하기 위해 $N$의 추가 메모리 공간이 필요하다.

***퀵 정렬***: 제자리에서 정렬을 수행함으로 메모리 공간을 거의 사용하지 않는다.

### 평균 시간 복잡도

***병합 정렬***: 시간 복잡도는 $NlogN$이지만 각 분할 단계마다 배열을 추가로 복사해야 하기 때문에 평균적으로 퀵 정렬보다 더 많은 연산이 발생한다.

***퀵 정렬***: 시간 복잡도는 $NlogN$이지만 피벗을 잘 선택하면 평균적으로 매우 빠르게 동작한다.


### 결론
퀵 정렬은 공간 복잡도가 $logN$으로 매우 효율적이고 평균 시간 복잡도가 우수하여 많은 라이브러리와 알고리즘에서 기본 정렬 알고리즘으로 사용된다.

반면 병합 정렬은 $N$의 추가 공간을 사용해야 하기 때문에 메모리 사용 측면에서 불리하며 평균적으로 퀵 정렬보다 성능이 떨어진다.

따라서, 공간 효율성과 평균 성능 측면에서 퀵 정렬이 병합 정렬보다 더 널리 사용된다.