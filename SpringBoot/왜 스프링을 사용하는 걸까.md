# Spring을 사용하는 이유

## POJO(Plain Old Java Object) 기반의 구성

특별한 규약이나 제약 없이 순수한 자바 객체를 의미한다.

> #### POJO의 특징
>
> - 간단함
> POJO는 자바의 기본 문법을 사용하여 정의된 객체로, 복잡한 프레임워크나 라이브러리의 영향을 받지 않는다.
>
> - 속성과 메서드
> 일반적으로 속성과 해당 속성에 접근하기 위한 getter와 setter 메서드를 포함한다.
>
> - 상속과 인터페이스
> 특정 상위 클래스나 인터페이스에 의존하지 않아 재사용성과 테스트용이성이 높다.
>
> - 비지니스 로직
> 주로 POJO는 비지니스 로직을 구현할 때 사용하며 에플리케이션의 데이터를 표현하는데 적합하다.

---

## DI(Dependency Injection, 의존성 주입)을 통한 객체 관계 구성

의존성 주입은 제어의 역전이 일어나는 것을 전제로 스프링 내부의 객체들 간의 관계를 관리할 때 사용한다.
의존성 주입은 특정 개체에 필요한 객체를 외부에서 결정하여 연결시키는 것을 말한다.

```
public class Test {
    private DI di = new DI();
    public void run() {
        di.run();
    }
}
```
```
public class DI {
    public void run() {
        System.out.println("의존성 주입은 이렇게 작동합니다.");
    }
}
```
Test 클래스는 DI를 강하게 의존하고 있다.
이렇게 강한 의존성은 여러가지 문제를 생기게 할 수 있다.

> #### 강한 의존성
> 소프트웨어 설계에서 두 컴포넌트가 서로 밀접하게 연결되어 있어
> 한 컴포넌트의 변경이 다른 컴포넌트에 큰 영향을 미치는 상태
>
> #### 강한 의존성의 문제
> - 유지보수의 어려움
> 객체 간의 의존성이 높아지게 되면, 하나의 객체를 수정할 때 다른 객체에 영향을 미칠 가능성이 높아지게 된다.
> 이로 인해 유지보수가 복잡해지고 버그 발생 확률이 높아진다.
> 
> - 단위 테스트의 어려움
> 강한 결합은 단위 테스트를 어렵게 만든다. 특정 개체를 테스트 하기 위해서는 그 객체가 의존하는 모든 객체를 함께 사용해야 하기 때문에 Mock 객체를 활용하기 어려워 진다.

```
public class Test {
    private DI di;
    public Test(DI di) {
        this.di = di;
    }
    public void run() {
        di.run();
    }
}
```
```
public class DI {
    public void run() {
        System.out.println("의존성 주입은 이렇게 작동합니다.");
    }
}
```
Spring은 IoC(제어의 역전)을 통해 의존성을 외부에서 주입함으로써 SOLID 원칙을 만족하는 설계가 가능하게 해준다.
> #### IoC(Inversion of Control)
> 소프트웨어 디자인 원칙 중 하나로, 프로그램의 흐름 제어를 개발자가 아닌 프레임워크가 담당하는 방식을 말한다.
> 객체의 생성과 관리, 의존성 주입 등을 개발자가 아닌 외부에서 처리하도록 하여, 코드의 결합도를 낮춘다.

### 단일 책임 원칙(SRP)
> 각 클래스는 하나의 책임만 가져야 한다.
- DI를 사용하여 객체가 자신의 의존성을 직접 관리하지 않고, IoC(스프링 컨테이너)가 이를 관리하게 함으로써 클래스는 자신의 비지니스 로직에만 집중 할 수 있게 된다.

### 개방 폐쇠 원칙(OCP)
> 확장에는 열려 있어야 하며, 수정에는 닫혀 있어야 한다.
- DI를 통해 의존성을 외부에서 주입받으면, 새로운 기능을 추가하기 위해 기존 코드를 수정할 필요 없이 새로운 구현체를 추가함으로써 기능 확장이 가능해진다.

### 리스코프 치환 원칙(LSP)
> 서브타입은 언제나 교체 가능해야 하며, 클라이언트는 서브타입을 사용할 수 있어야 한다.
- 인터페이스나 추상 클래스에 의존하는 DI를 통해 구현체를 교체할 수 있음으로 LSP를 잘 준수하고 있다. 클라이언트는 특정 구현에 의존하지 않고 인터페이스에 의존하게 된다.

### 인터페이스 분리 원칙(ISP)
> 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다.
- DI는 여러개의 작은 인터페이스를 만들어 각각의 구현체가 해당 인터페이스를 구현하게 함으로써, 클라이언트가 필요 없는 메서드에 의존하지 않도록 한다.

### 의존성 역전 원칙(DIP)
> 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 두 모듈 모두 추상화에 의존해야 한다.
- DI는 구현체에 의존하는 대신 인터페이스에 의존하도록 설계함으로써 DIP를 만족한다.
고수준 모듈은 저수준 모듈의 구체적인 구현에 의존하지 않고 추상화에 의존하게 된다.

---

## AOP( Aspect-Oriented Programming, 관점지향 프로그래밍) 지원

스프링은 AOP를 통해 반복적인 코드(공통 관심사)를 줄이고 개발자가 핵심 비지니스 로직에만 집중 할 수 있도록 지원한다.
> 비지니스 로직은 아니지만 보안, 로그, 트랜젝션과 같이 반드시 처리가 필요한 부분을 스프링에서는 공통 관심사라고 한다. 공통 관심사를 분리하지 않게 되면 핵심 비지니스 로직과 공통 관심사의 로직이 섞여 유지보수를 어렵게 한다.

### 단일 책임 원칙(SRP)
> 각 클래스는 하나의 책임만 가져야 한다.
- AOP를 사용하면 로깅, 트렌젝션 관리, 보안 등의 공통 관심사를 분리 할 수 있다. 이를 통해 비지니스 로직을 담당하는 클래스는 오로지 비지니스 로직에만 집중 할 수 있게 된다.

### 개방 폐쇠 원칙(OCP)
> 확장에는 열려 있어야 하며, 수정에는 닫혀 있어야 한다.
- 새로운 Aspect(관심사를 모듈화)를 추가함으로써 기존의 비지니스 로직을 수정하지 않고 기능을 확장 할 수 있다.

### 리스코프 치환 원칙(LSP)
> 서브타입은 언제나 교체 가능해야 하며, 클라이언트는 서브타입을 사용할 수 있어야 한다.
- AOP는 비지니스 로직의 객체와 Aspect 간의 결합도를 낮추어 클라이언트 코드가 Aspect의 존재를 알 필요가 없게 된다. 이를 통해 다양한 구현체를 교체해도 기존 로직에 영향을 주지 않는다.

### 인터페이스 분리 원칙(ISP)
> 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다.
- AOP를 사용하면 인터페이스를 통해 필요한 기능만을 제공 할 수 있다. Aspect가 특정 기능만 제공하는 방식으로 설계되면, 클라이언트는 필요한 기능만 사용할 수 있어 ISP를 만족한다.

### 의존성 역전 원칙(DIP)
> 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 두 모듈 모두 추상화에 의존해야 한다.
- AOP는 비지니스 로직과 공통관심사를 분리하여 고수준 모듈이 저수준 모듈에 의존하지 않도록 한다. Aspect는 인터페이스나 추상 클래스에 의존하게 되고 이는 DIP를 준수하는 설계로 이어진다.

- PSA (Portable Service Abstractions)
 
---

## 기술에 대해 공통으로 사용 할 수 있게 추상화된 레이어를 제공한다.

Spring은 Spring Web MVC, Spring Transaction, Spring Cache등 다양한 PSA를 제공한다.

```
@RestController
public class BoardController {
    @PostMapping
    public ResponseEntity<BoardResponse.FindBoard> save(@RequestBody BoardRequest.SaveBoard request){
        // 코드
    }
}
```
클래스에 @RestController 어노테이션을 사용하여 컨트롤러 역할을 하는 클래스로 만들 수 있다.
@GetMapping, @PostMapping 어노테이션을 사용해 요청에 매핑이 가능하게 해준다.